package com.vco;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;
import org.supercsv.cellprocessor.ift.CellProcessor;
import org.supercsv.io.CsvListWriter;
import org.supercsv.io.ICsvListWriter;
import org.supercsv.prefs.CsvPreference;
import org.supercsv.quote.AlwaysQuoteMode;
import org.supercsv.quote.QuoteMode;

import model.BatchLog;
import model.BatchLogDtl;
import model.BatchLogFileOutput;
import model.JobStepsXref;
import model.Step;

/**
 * Receives data from other Steps (like ExtractDBStep) and
 * outputs that data into CSV file(s).
 * 
 * @author Van Cahall
 *
 */

public class GenerateCSVStep extends StepManager {
	
	// Step configuration
	public Boolean quoteAllOutputFields = false;  // Surround all fields in exported CSV with quotes

	
	// Stores the full path/filename of generated CSV files
	public List<String> alternateOutputData;
	
	// Keep track of rows and paging
	private int totalFilesGenerated = 0;   // CSV files generated by this step
	private Long totalRowsGenerated = 0L;  // Row count across all generated files
	private Long totalRowsThisFile = 0L;   // Row count for current file
	public Long max_rec_per_file = 0L;  // Will be referenced by JobManager
	private Long pageCount=0L; // Pages of data sent in from another step (not necessarily db or CSV pages)

	private BatchLogDtl log_dtl;
	
	FileWriter currentOutputFile = null;
	String currentOutputFilename = new String();
	private String defaultCSVFilename = "vbatch_j{batch_num}_d{dt}_{seq}.csv";
	
	// private vars
	private String startingDateTimeStr;
	private Date startingDateTime;
	public static Logger log = null;
	
	// CSV generation
	ICsvListWriter listWriter = null;
	private static final CsvPreference ALWAYS_QUOTE = 
		    new CsvPreference.Builder(CsvPreference.STANDARD_PREFERENCE).useQuoteMode(new AlwaysQuoteMode()).build();
	
	
	public GenerateCSVStep(JobManager jm, JobStepsXref jobStepXref) {
		log = Logger.getLogger(VBatchManager.vbatch_version);	
		this.job_manager = jm;
		this.jobStepXref = jobStepXref;
		
		// If this step has a filename prefix defined, use that.  Otherwise use the default.
		if (this.jobStepXref.getStep().getOutputFilenamePrefix() != "") {
			this.defaultCSVFilename = this.jobStepXref.getStep().getOutputFilenamePrefix();
		}
		this.alternateOutputData = new ArrayList<String>();
		
		// Get extract_max_rec_per_file from the step config
		if (this.jobStepXref.getStep().getExtractMaxRecPerFile() != null) {
			this.max_rec_per_file = this.jobStepXref.getStep().getExtractMaxRecPerFile();
		}
			
	}
	
	/**
	* Basic workflow methods
	* ----------------------
	*/
	
	@Override
	public boolean init() {
		try {
			// The startingDateTime should be the same for every file 
			// this step generates, so we create it during init.
			DateFormat df = new SimpleDateFormat("MM-dd-yyyy_HH-mm-ss");
			this.startingDateTime = Calendar.getInstance().getTime();
			this.startingDateTimeStr = df.format(this.startingDateTime);
			
		}
		finally {
			/**
			if( this.listWriter != null ) {
                try{
                	this.listWriter.close();
                }
                catch (IOException e) {
                	
                }
                
                }
              **/
				
			
		}
		return true;
	}
	
	/**
	 * JobManager calls start() on this step once the previous step
	 * completes.  Generally, by the time start() gets called on 
	 * this step, all data will already have been sent to it
	 * from previous steps via processPageOfData(), 
	 * and this step will already have generated all csv files.
	 * 
	 * So we just set the appropriate flags on the step, write
	 * to the logs, and return true to JobManager to indicate that
	 * this step has no further work to be done.
	 */
	@Override
	public boolean start() throws Exception {
		
		if (this.running) {
			this.completed=true;
			this.failed=false;
			
			// Mark this step complete in the logs
			this.logComplete();
			
		}
		else {
			// Log the start of this step
			this.running = true;
		}
		
		// Return execution to JobManager
		return true;
		
	}
	
	/**
	 * A page of data has been sent from a previous step, via JobManager,
	 * into this step to be converted into CSV rows.
	 */
	@Override
	public boolean processPageOfData(List<Object> pageOfData) throws Exception {
		// If this is the first page of data we've received,
		// and log the start of the job
		if (!this.running) {
			// Set this.running = true so we know this step has been
			// started, even if start() has not been called yet.
			this.running=true;
			this.logStart();
		}
		
		
		// Prepare to process this page of data
		this.pageCount++;
		
		try {
			// Loop over the rows of data in this page
			for (int i = 0; i < pageOfData.size(); i++) {
				// Create the csv file before outputting the first row
				if (this.currentOutputFile == null && i == 0) {
					this.currentOutputFilename = this.generateNextCSVFile();
				}
				
				// Write this row to the CSV
				List row = (List)pageOfData.get(i);
				String rowStr = this.generateCSVRow(row);
				this.currentOutputFile.append(rowStr);
				this.currentOutputFile.flush();
				log.debug("Writing CSV row # :" + (i+1) +  ": " + rowStr.trim());
				// Update the counters
				this.totalRowsThisFile++;
				this.totalRowsGenerated++;
			}
			
			// Filename with .tmp replaced with .csv
			int pos = this.currentOutputFilename.length()-5;
			String newFilename = this.currentOutputFilename.substring(0,pos) + this.currentOutputFilename.substring(pos).replaceFirst(".tmp", ".csv");
			
			log.info("Generated CSV file: " + newFilename 
					+ " (" + this.totalRowsThisFile + " rows)");
			// Close the output file
			closeCurrentOutputFile();
			
			// Send the .tmp file to GenerateTRGStep
			this.job_manager.submitPageOfData(this.alternateOutputData, this);
			// Clear the list of generated csvs since we've generated the .tmp
			this.alternateOutputData = new ArrayList<String>();
			
		}
		catch( Exception e) {
			e.printStackTrace();
			throw e;
		}
		finally {
			
		}
		
		return true;
	}

	/**
	 * Generated files are named xxx.tmp until the file is complete.  This function
	 * is then called to rename them to xxx.csv
	 */
	private boolean renameTMPToCSV() throws Exception {
		
		boolean success = false;
		int pos = this.currentOutputFilename.length()-5;
		String newFilename = this.currentOutputFilename.substring(0,pos) + this.currentOutputFilename.substring(pos).replaceFirst(".tmp", ".csv");
		// Open the tmp file
		File tmpFile = new File("output/" + this.currentOutputFilename);
		File csvFile = new File("output/" + newFilename);
		// Make sure the csv file doesn't already exist
		csvFile.delete();
		
		success = tmpFile.renameTo(csvFile);
		this.log.debug("Renamed .tmp file to: " + newFilename + " (" + success + ")");
		// Update this filename in this.alternateOutputData as well,
		// since that will be sent to the trg step
		this.alternateOutputData.set(0,	this.alternateOutputData.get(0).replace(".tmp", ".csv"));
		this.currentOutputFilename = "output/" + newFilename;
		
		return success;
	}

	/**
	 * Close an existing CSV file and log it
	 * in batch_log_file_output table.
	 * @throws IOException
	 */
	private void closeCurrentOutputFile() throws Exception {
		// rows
		Long rows = this.totalRowsThisFile;
		
		// Close the output file
		if (this.currentOutputFile != null) {
			this.currentOutputFile.flush();
			this.currentOutputFile.close();
			this.currentOutputFile = null;
		}
		
		// Rename .tmp file to .csv
		renameTMPToCSV();
		// Update counters
		this.totalRowsThisFile=0L;
		
		// Create new entry in batch_log_file_output log table for this file
		BatchLogFileOutput log_entry = new BatchLogFileOutput();
		log_entry.setBatchLog(this.job_manager.batch_log);
		log_entry.setFilename(this.currentOutputFilename);
		log_entry.setNumRecords(rows);
		log_entry.setCreateDt(this.startingDateTime);
		this.job_manager.db.persist(log_entry);
		
	}
	
	/**
	 * Generate the next CSV file.
	 * 
	 * Returns the name of the generated file
	 */
	
	private String generateNextCSVFile() {
		String newFileName = this.defaultCSVFilename;
		try {
			// Increment the counters
			this.totalFilesGenerated++;
			
			/**
			 * Replace any variables in STEPS.OUTPUT_FILENAME_PREFIX with the values from this batch
			 */
			newFileName = newFileName.replace("{dt}", this.startingDateTimeStr);
			newFileName = newFileName.replace("{seq}", Integer.toString(this.totalFilesGenerated));
			newFileName = newFileName.replace("{batch_num}",  this.job_manager.batch_log.getBatchNum().toString());
			
			// Initially we write the rows into xxx.tmp, later to be renamed to xxx.csv on success
			String tmpFilename = new String();
			if (newFileName.toLowerCase().endsWith(".csv")) {
				int pos = newFileName.length()-5;
				tmpFilename = newFileName.substring(0,pos) + newFileName.substring(pos).replaceFirst(".csv", ".tmp");
				newFileName = tmpFilename;
			}
			// Create the file
			this.currentOutputFile = new FileWriter("output/" + tmpFilename,true);
			this.alternateOutputData.add("output/" + tmpFilename);
			
			// Reset counters
			this.totalRowsThisFile=0L;
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return newFileName;
	}
	
	
	
	/**
	 * Converts a row of data (list of strings) into a CSV-formatted String.
	 * @param row
	 * @return String
	 */
	
	private String generateCSVRow(List row) {
		//this.totalRowsGenerated++;
		String retval = "";
		for (int i=0; i < row.size(); i++) {
			String fieldVal = (String) row.get(i);
			if (this.quoteAllOutputFields)
				retval += "\"";
			if (row.get(i) != null) {
				retval += row.get(i);
			}
			if (this.quoteAllOutputFields)
				retval += "\"";
			// Add comma after field (unless last field)
			String comma = (i < row.size() - 1) ? "," : "";
			retval += comma;
		}
		retval += "\n";
		return retval;
	}
	
	@Override
	public boolean finish() {
		
		return true;
	}
	
	/************************
	 * Logging
	 * 
	 ************************/
	
	/**
	 * This Step is starting.  Make the appropriate log entries.
	 */
	
	private void logStart() {
		
//		this.job_manager.db.getTransaction().begin();
		// Create entry in batch_log_dtl
		this.log_dtl = new BatchLogDtl();
		this.log_dtl.setBatchLog(this.job_manager.batch_log);
		
		String msg = "Step [" 
				+ this.jobStepXref.getStep().getType() + " : " + this.jobStepXref.getStep().getLongDesc() 
				+ "]";
		this.log_dtl.setLongDesc(msg);
		this.log_dtl.setStepsId((Long)this.jobStepXref.getId());
		this.log_dtl.setStepsShortDesc(this.jobStepXref.getStep().getShortDesc());
		this.log_dtl.setStepType(this.jobStepXref.getStep().getType());
		this.log_dtl.setJobStepsXrefJobStepSeq(this.jobStepXref.getJobStepSeq());
		this.log_dtl.setStartDt(new Date());
		this.log_dtl.setStatus("Started");
		
		// Log job settings used to run this job
		this.log_dtl.setClassPath(this.jobStepXref.getStep().getClassPath());
		this.log_dtl.setExtractMaxRecsPerFile(this.jobStepXref.getStep().getExtractMaxRecPerFile());
		this.log_dtl.setOutputFileFormat(this.jobStepXref.getStep().getOutputFileFormat());
		this.log_dtl.setOutputFilenamePrefix(this.jobStepXref.getStep().getOutputFilenamePrefix());
		this.log_dtl.setOutputFilenameSuffix(this.jobStepXref.getStep().getOutputFilenamePostfix());
		
		// Commit log entry
		this.job_manager.db.persist(this.log_dtl);
//		this.job_manager.db.getTransaction().commit();
		
	}
	
private void logComplete() {
		
		if (!this.job_manager.db.getTransaction().isActive()) {
			this.job_manager.db.getTransaction().begin();
		}
		
		// Create entry in batch_log_dtl
		this.log_dtl.setEndDt(new Date());
		this.log_dtl.setStatus(BatchLog.statusComplete);
		
		// Commit log entry
		this.job_manager.db.persist(this.log_dtl);
		this.job_manager.db.getTransaction().commit();
		log.info("Step completed.");
	}
}
